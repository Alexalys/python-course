### Колекции

1. Упорядоченные контейнеры
2. Списки 
3. Кортежи
4. Словари
5. Множества

Коллекция в Python — программный объект (переменная-контейнер), хранящая набор значений одного или различных типов, 
позволяющий обращаться к этим значениям, а также применять специальные функции и методы, зависящие от типа коллекции. 

**Простым языком**, коллекция -- это хранилище информации, каталог построенный по какому-то принципу.

Хранилища бывают разными: может быть мешок из которого ты достаешь сожержимое наугад, может быть разложенный по 
алфавиту каталог в котором очень легко что-то найти или труба из которой можно достать только то, что лежит с краю и т.п.

В зависимости от целей можно и нужно применять различные коллекции. Например, чтобы быстро найти что-то используют 
словари; для хранения упорядоченных данных, когда порядок имеет значение -- списки и кортежи; для хранения только
уникальных элементов -- множества; для хранения символов -- строки и т.п.

В этом уроке мы выучим основные коллекции Python и научимся работать с ними. Это основа языка и знание возможностей
коллекций яляется не только очень полезным навыком, но и определяющим для разработчика на Python.

Знание основ синтаксиса и колелкций достаточно для того, чтобы решить любую прикладую задачу на Python. Конечно, 
эффективность такого решения будет далека от оптимальной, но принципиальная возможность есть. Освоим этот материал 
вы будете обладать достаточным инструментарием чтобы решать несложные задачи автоматизации с помощью Python.

Коллекции -- это мощнейший инструмент для работы с информацией, Python целиком строится всего на нескольких основных
коллекциях и вся сложность, все уровне абстрации собираются из них как здание из кирпичиков. При этом сами по себе
коллекции -- это достаточно понятные и простые объекты.

Основные свойства коллекций:

* Упорядоченность. Упорядоченный контейнер (коллекция) дает возможность обращаться к своим элементам по индексу (номеру)
    и гарантирует, что порядок элементов сохраняется.
* Изменяемость. Если коллекция изменяемая, то её содержимое можно изменять не создавая новую коллекцию. Например 
    добавлять, удалять, заменять элементы коллекции.
* Уникальность. Уникальность касается содержимого коллекции, допускается ли хранения одинаковых объектов.

## Общие для всех коллекций операции

Любая колекция позволяет проверить входит ли элемент в эту коллекци (есть ли там такой же). 
Для этого используется оператор `in`.

Любая коллекция позволяет узнать количество элементов в ней при помощи функции `len`.

По любой коллекции можно пройти с помощью цикла `for` и на каждой итерации в цикле будет получен один из элементов
этой коллекции. **ВАЖНО** помнить, что итерируясь в цикле по коллекции её нельзя изменять, это приведет к 
неопределенности и вызовет синтаксическую ошибку.

## Упорядоченные контейнеры

К упорядоченным контейнерам в Python относятся списки и кортежи. (С версии Python > 3.8 словари также гаранируют 
порядок элементов).

Под упорядоченностю следует понимать свойство контейнера сохранять порядок элементов при работе с ним, удаляя элемент, 
добавляя новый делая вставку/удаление с конца/начала/средины вы гарантируете что все элементы кроме тех, 
которых непосредственно коснулась операция, сохраняют порядок.

Самым полезным свойством упорядоченности является возможность доступа к элементам контейнера по индексу
этого элемента в контейнере.

В Python синтаксис доступа по индексу выглядит так:
```python
some_iterable = ["a", "b", "c"]
first_letter = some_iterable[0]
middle_one = some_iterable[1]
last_letter = some_iterable[2]
```

В первой строке мы создали список из трёх первых букв английского алфавита (со списками познакомимся далее). 

Во второй стоке мы сохранили в переменную `first_letter` букву `"a"`, первый элемент `some_iterable`. __Индекс__ в Python
начинается с `0`, как и в большинстве языков программирования и индексом `"a"` есть `0`. 

Третья строка -- это обращение ко второму элементу `some_iterable`, его индекс равен `1` -- это буква `"b"` и мы 
сохраняем её в `middle_one`.

Четвертая строка -- это обращение к последнему элементу `some_iterable`, букве `"c"`, мы сохраним её в `last_letter` и 
её индекс равен `2`.

Python поддерживает инексирование элементов с конца. Для этого надо добавить `-` и указать номер элемента с конца.
Поскольку в Python `-0 == 0`, то первый элемент с конца -- это `-1`, второй -- `-2` и так далее. 
Наш пример можно переписать используя индексирование с конца вот так:
```python
some_iterable = ["a", "b", "c"]
first_letter = some_iterable[-3]
middle_one = some_iterable[-2]
last_letter = some_iterable[-1]
```

Также, общим для всех контейнеров Python есть возможость перебрать все элементы контейнера в цикле или 
проитерировать контейнер. Для этого используется цикл `for`, с ним мы детальнее ознакомимся далее. 

Давайте проитерируем наш контейнер `some_iterable` в цикле и выведем в консоль что мы получаем на каждой итерации:
```python
some_iterable = ["a", "b", "c"]

for i in some_iterable:
    print(i)
```
В консоли мы увидим:
```
a
b
c
```
Таким образом мы можем перебрать все элементы контейнера без необхожимости определять внешний счётчик, проверять
не перебрали ли мы уже все элементы и т.п. Python делает это за нас. Это очень удобное свойство значительно
упрощающее написание кода и делая код более понятным.

Такой перебор имеет ограничение -- __НЕЛЬЗЯ ИЗМЕНЯТЬ КОНТЕЙНЕР ВО ВРЕМЯ ИТЕРИРОВАНИЯ ПО НЕМУ__. Такая операция 
приводит к неоднозначности и вызывает синтаксическую ошибку.

## Списки

Список -- __упорядоченный изменяемый__ контейнер данных. Список -- это наиболее часто используемый контейнер особенно
среди начинающих разработчиков. Списки похожи на массивы в других языках, но в силу данамической природы Python имеют 
ту особенность, что не диктуют разработчику тип данных, который можно поместить в этот контейнер. Списки в Python
могут содержать любые типы данных в любом удобном порядке.

Для создания пустого списка есть два способа:
```python
my_list = list()

empty_list = []
```

Чтобы создать заполненный список:
```python
not_empty = [1, 2]
```

### Методы списков

* Добавление элемента в конец списка: ```my_list.append(element)```
* удаление элемента из списка, вызовет ошибку если такого элемента нет в списке: ```my_list.remove(element)```
* Вернуть `i`-ый элемент и удалить его из списка ```i_element = my_list.pop(i)```. За замовчуванням ```i = -1```
* Расширить список `a_list` элементами из `b_list`: ```a_list.extend(b_list)```
* Вставить `x` на на позицию с индексом `i`: ```my_list.insert(i, x)```
* Очистить список: ```my_list.clear()```
* Найти индекс первого элемента в списке равного `x`: ```index = my_list.index(x)```
* Вернуть количество элементов в списке равных `x`: ```x_number = my_list.count(x)```
* Отсортиорвать список по возрастанию: ```my_list.sort(key=None, reverse=False)```
* Поменять порядок элементов в списке на обратный: ```my_list.reverse()```
* Вернуть копию списка: ```copy_of_my_list = my_list.copy()```

Самым главным свойством списков является изменяемость списков, вы можете поменять значение любого элемента списка:
```python
some_iterable = ["a", "b", "c"]
some_iterable[1] = "Z"
print(some_iterable)    # ["a", "Z", "c"]
```

Также полезно помнить о том, что добавление элемента в конец списка (`append`) и удаление с конца (`pop`) 
происходит за константное время. В то время, как добавление и удаление не последенего элемента зависит от размеров 
списка.

## Кортежи

Кортежи в Python -- это упорядоченные неизменяемые множества элементво. Элементов кортежа как и списка может быть любой
тип данных. Главное отличие между кортежами и спимками -- это то, что кортежи нельзя изменять, 
нельзя добавлять/удалять/переставлять элементы. Это сильно ограничивает их применение по сравнению со списками, но
даёт возможность использовать кортежи как ключи для словаря или элементы множества (о словарях и множествах будет 
дальше).  

Чтобы создать пустой список есть два способа, хотя и не совсем понятно зачем нужен пустой список :-)
```python
my_tuple = tuple()
another_tuple = ()
```

Создание же не пустых списков происходит следующим образом:
```python
not_empty = (1, 2, 3)
```

При попытке изменить кортеж вы получите сообщение об ошибке:
```python
not_empty[3] = 's'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-6-0e33ea041f91> in <module>()
----> 1 not_empty[3] = 's'

TypeError: 'tuple' object does not support item assignment
```

Есть одна важная особенность создания списков, это создание списков с одним элементом. Дело в том, что Python
использует круглые скобки как матиематические символы е если написать выражение вида `a = (1)` возникает неопределенность.
Интерпритатор понимает такое выражение как сугубо математическое и просто убирает лишние скобки присваивая `a` значение 
`1`. Чтобы указать, что это не математическая операция, а именно кортеж надо добавить запятую после значения. Тогда
интерпритатор однозначно поймёт что вы хотете создать кортеж с одним элементом: 
```python
a = (1, )
```

## Словари

Словарь -- это контейнер котрый хранит пары ключ-значение, характеризуется константным временем поиска.
Ключом может быть любой неизменяемый тип данных Python (число, строка, кортеж, пр.). 
Невозможно использовать в качестве ключа списки, словари, множества.
Значением словаря может быть любой тип данных Python включая пользовательские типы.

Подробнее со словарями можно ознакомиться на страницах официальной документации:
[тут](https://docs.python.org/3.8/library/stdtypes.html#mapping-types-dict) і 
[тут](https://docs.python.org/3/tutorial/datastructures.html#dictionaries).

Пустой словарь можно создать одним из двух способов:
```python
empty_dict = {}
another_empty_dict = dict()
```

Создать непустой словарь можно следующим образом:
```python
some_dict = {
    "key": "value",
    1: 2,
    ("a", "b"): [1, 2, 3]
}
```
Для создаия заполненного словаря некоторыми значениями достаточно перечислить пары
ключ-значение через запятую внутри фигурных скобок, ключ идёт первым, потом двоеточие и значение.

В примере показано применение в качестве ключей строки, числа, кортежа. 

Запись пары ключ-значение в уже существующий словарь происхоит при помощи квадратных скобок и
оператора присвоения `=`:

```python
not_empty = {"key": "value"}
not_empty["new_key"] = "new value"
print(not_empty)    # {"key": "value", "new_key": "new value"}
``` 

### Методы словарей
Словари поддерживают следующие методы:

* ```pop(key)``` -- возвращает значение элемента и удаляет пару ключ-значение из словаря
* ```update(another_dict)``` -- росширяет словарь значениями из другого словаря
* ```popitem()``` -- возвращает кортеж (ключ, значение) и удаляет эту пару из словаря 
* ```clear()``` -- очищает словарь не создавая нового
* ```fromkeys(keys, value)``` -- для всех ключей из `keys` добавляет пару ключ-значение в словарь 
    (у всех значением будет `value`)
* ```copy()``` -- возвращает поверхностную копию словаря
* ```items()``` -- возвращает генератор при помощи которого можно перебрать все пары ключ-значение
* ```keys()``` -- возвращает генератор для перебора всех ключей
* ```values()``` -- возвращает генератор для перебора всех значений
* ```setdefault(key[, default])``` -- если ключ `key` есть в словаре, то возвращает его значение, 
    или добавляет пару `key: default` и возвращает `default`
* ```get(key[, default])``` -- не вызывает исключения, если ключа нет в словаре, возвращает `default`, по умолчанию 
    `default=None`.

### Циклы и словари

Итерирование по словарю -- это очень часто встречающийся блок кода и полезно уметь это делать.

Для начала следует сказать, что словарь сам по себе -- это итерируемый контейнер и по нему можно итерироваться в
цикле `for` без необходимости заводить какой-то внешний счётчик и т.п. Создадим словарь в котором ключами будут числа,
а значениями -- числительные на английском:
```python
numbers = {
    1: "one",
    2: "two",
    3: "three"
}
```

Теперь давайте просто проитерирем по словарю и выведем что нам возвращает итератор на каждой итерации:
```python
for x in numbers:
    print(key)
```
В выводе вы увидите:
```
1
2
3
```
Итерируя по словарю вы перербираете ключи словаря. Точно такое же поведение можно получить используя метод `keys`,
но так вы явно укажете, что хотите перебрать ключи:
```python
for key in numbers.keys():
    print(key)
```
Ответ будет точно таким же:
```
1
2
3
```

Часто необходимо перебрать именно знаяения словаря, для этого воспользуемся методом `values`:
```python
for val in numbers.values():
    print(val)
```
В выводе будет:
```
one 
two
tree
```

И переберем пары ключ значение используя метод `items`. На каждой итерации мы получим пару (ключ, значение):
```python
for key, value in numbers.items():
    print(key, value)
```
Вывод:
```
1 one
2 two
3 three
```

Что __нельзя__ делать пока итерируетесь по словарю: нельзя удалять элементы из словаря, нельзя доавлять элементы в 
словарь. Но можно перезаписывать значения, если вы итериуетесь по ключам. Общее правило такое же, как и для других
множеств: __нельзя изменять объект во время итерирования по нему__. Хотя такая возможность и кажется удобной и полезной,
на самом деле, это может привести к неопределенности и бесконечным циклам. Именно по этой причине попытка изменить
словарь пока вы перебераете его элементы в цикле приведет к синтаксической ошибке.  

## Множества
Мнодество -- это неупорядоченный контейнер, который сожержит только уникальные элементы. В множество можно 
добавлять только неизменяемые типы данных. Поддерживает математические операции над множествами и характеризуется
константным временем проверки на вхождение элемента в контейнер.

Есть только один способ создать пустое множество:
```python
a = set()
print(a)    # set()
```

Для создания заполненного множества достаточно передать любой итерируемый объект в функцию `set`:
```python
a = set('hello')
print(a)    # {'e', 'h', 'l', 'o'}
```
Или же воспользоваться синтаксисом с фигурными скобками (как у словарей), но элементы в фигурных скобках просто
перечислить через запятую без двоеточий:
```python
b = {1, 2, 3, 4}
```

### Методы множеств
Множества поддерживают следующие методы:

* ```add(elem)``` -- добавляет элемент в множество
* ```remove(elem)``` -- удаляет элемент из множества, вызывает исключение, если такого элемента нету
* ```discard(elem)``` -- удаляет элемент из множества и не вызывает исключения если его нету
* ```pop()``` -- возвращает первый элемент из множества и удаляет его
* ```clear()``` -- очищает множество без создания нового
* ```isdisjoint(other)``` -- возвращает ```True```, если нету общих элементов с ```other```
* ```copy()``` -- возвращает копию множества

### Математическе операции над множествами

Давайте детальнее рассмотрим какие полезные математические операции можно производить над множествами. 
Для начала создадим множества `a` и `b`: 
```python
a = set('hello')
print(a)    # {'e', 'h', 'l', 'o'}

b = set('hi there!')
print(b)    # {'r', ' ', 'i', 'e', '!', 'h', 't'}
```

Чтобы найти общие элементы для двух множеств выполним над ними операцию `&` (`AND`):
```python
a & b   # {'e', 'h'}
```

Найдем все элементы из двух множеств кроме общих при помощи оператора `^` (`XOR`):
```python
a ^ b   # {' ', '!', 'i', 'l', 'o', 'r', 't'}
```

Объединение множеств, или просто все элементы из обоих множеств находятся при помощи оператора  `|` (`OR`):
```python
a | b   # {' ', '!', 'e', 'h', 'i', 'l', 'o', 'r', 't'}
```

Множества -- это очень мощниый инструмент когда необходимо найти уникальные элементы в каком-то наборе и и убрать
дубликаты. Множество -- это также самый быстрый способ найти общие или отличные элементы из нескольких наборов.


## Задачи

* создайте список `alphabet_list` из кортежа `a_tup`.
* Сохраните в словаре `alphabet` символы из `string.ascii_letters` (списко букв английского
    алфавита). В качестве ключа используйте букву, а значение -- её порядковый номер в `string.ascii_letters`.
* `char_counter` получает на вход строку `text` а возвращает словарь в котором для каждой
    буквы из `char_counter` записано сколько раз она встречается в `char_counter`. Учитываются только буквы.
* `unique_letter` возвращает множество уникальных букв из `text`, только букв.
* `unique_words` возвращает кортеж из двух множеств. Первое -- это общие слова для `text1` и `text2`,
    второе -- это уникальные слова, которые есть только в `text1` или только в `text2`.

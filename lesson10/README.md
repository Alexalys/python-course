# Об'єктно-орієнтованими програмування
## Визначення класу

Класи &mdash; це структура мови програмування, яка дозволяє об'єднати в рамках однієї сутності змінні різних типів (поля) 
та функції (методи). 
Клас &mdash; це опис того, яка буде поведінка відповідної сутності. 
При чому саму сутність, яка отримує дані та виконує дії з ними називають об’єктом (об’єкт є екземпляром класу).

Наочною метафорою для класів і об’єктів може бути форма для випікання печива і печиво. 
Клас &mdash; це форма, яка задає суть об’єкту, які поля він містить і як можна оперувати з цими полями. 
А об’єкт класу &mdash; це печиво, воно обов’язково буде заданої класом форми, але начиння кожної печенюшки може бути різним.

Атрибути класу &mdash; це форма класу, все що він містить в собі. До атрибутів класу відносять поля
і методи.  

Поля класу &mdash; це змінні, в яких міститься інформація. 
Полем може бути будь-який об’єкт Python. Зазвичай це змінна, або контейнер (словник, список, рядок, тощо).

Метод класу &mdash; це функція, яка оперує з полями класу і/або аргументами, що передаються в метод.

Є нестрога домовленість називати клас з великої літери і якщо назва складається з декількох слів, 
то всі слова з великої літери без додаткових символів між ними.
### Приклад на розуміння класів
**Клас** - це поєднання **полів** (*як змінні* - зберігають дані), а також **методів** (*як функції* - отримують дані, їх опрацьовують та повертають результат).  
Наприклад, в нас є песик, який вміє виляти хвостом, коли ми називаємо його ім'я.  
**Як це запрограмувати?**  
Створимо **клас песик** (dog), який буде мати **поле - ім’я** (value), та **метод - виляти хвостом** (vh). Скажемо нашому песику певне слово (передамо методу vh параметр item), якщо це слово збігається з  його ім’ям - він буде віляти хвостиком (метод vh поверне True), якщо це якесь інше слово - не буде виляти хвостиком (метод vh поверне False)
```python
class Dog:
    value = 'Sirko'
    def vh(self, item):
        out = False
        if item == self.value:
            out = True
        return  out
```
Але так у нас всі собаки будуть мати ім’я Сірко. Тож створимо можливість надати нашому песику нове ім’я. Створимо метод `newName`, який отримає значення імені (параметр `value`) та збереже його у відповідному полі (поле `self.value`).
```python
class Dog:
    value = ''
    def newName(self,value):
        self.value = value
    def vh(self, item):
        out = False
        if item == self.value:
            out = True
        return  out
```

## Створення класу та об'єкту класу
Створення класу починається з ключового слова `class` після якого йде назва класу і перелік класів, 
які він успадковує в дужках через кому, якщо такі є. Після цього ставиться двокрапка і з наступного
рядку описуються атрибути класу.

```python
# Створимо клас User з атрибутами name i age
class User:
    name = 'UserName'
    age = 15

# Створимо об’єкт класу User
user1 = User()
print(user1.name)   # Поверне 'UserName'
print(user1.age)    # Поверне '15'

# Створимо ще один об’єкт класу User
user2 = User()
user2.name = "John"
user2.age = 90
print(user2.name)   # Поверне 'Jhon'
print(user2.age)    # Поверне '90'

# Перевіримо, що це різні об’єкти
print(user1 is user2)   # Результатом буде False, це різні об’єкти
```

## Поля і методи класу
### Методи класу
Методи класу &mdash; це функції, які працюють з полями класу. Щоб метод класу міг працювати з іншими методами і
полями класу, першим аргументом будь-якого методу завжди виступає сам об’єкт класу (ну майже завжди).

Для першого аргументу можна використати будь-яку назву, що не викликає синтаксичної помилки, 
однак, є домовленість завжди використовувати `self`.

```python
class Human:
    name = ""

    def hello(self, val):
        if self.name:
            # Якщо ім'я задано, повернемо рядок з іменем.
             return f"Hello {val}! I am {self.name}."
        else:
            # Якщо ім'я не задано, повернемо рядок без імені.
            return f"Hello {val}!"

bill = Human()
print(bill.hello("John"))   # Поверне 'Hello John!'

bill.name = "Bill"
print(bill.hello("John"))   # Поверне 'Hello John! I am Bill.'
```

## \_\_init\_\_ 
## Doc strings.
## Спадкування
**Спадкування у програмуванні** - це засіб отримати якесь готове рішення, 
але з можливістю додати до цього рішення щось нове.   

Наприклад - є людина (її описує клас `Human`), в якої є ім'я (поле `name`) і яка вміє говорити власне ім'я (метод `voice`).  

Але в ІТ-компанії працює не просто людина, а менеджер (клас `Manager`), який знає власне ім'я та вміє його називати. Можна описувати ім'я в класі `Manager` окремо, а можна, і це значно зручніше, успадкувати його від класу людини і лише навчити менеджера "спонукати розробника" (метод `push_developer`).


Також в ІТ-компанії працює Python-розробник (клас `PythonDeveloper`), який є людиною (наслідує клас `Human`), але розуміє, що він знає мову програмування (значення поля `field_description`) та що ця мова є Python (значення поля `value`). І вміє про це писати в форматі ключ: значення (метод `make_some_code`)

В програмуванні успадкування робить доступним дочірнім класам поля і методи батьківських класів.

Створимо клас `Human` з методом `voice` &mdash; це буде батьківський клас для класів
`Manager`, `PythonDeveloper`. При створенні дочірнього класу, треба позначити батьківський клас, вказавши його назву в дужках, відразу після назви класу який створюєте, наприклад:
```python
class Human:    # Створюємо батьківський клас
    name = ''
    def voice(self):
        print(f"Hello! My name is {self.name}")
    
class PythonDeveloper(Human):  # Створюємо дочірній клас, який успадковує клас `Human`
    field_description = "My Programming language"
    value = "Python"
    def make_some_code(self):
        return self.field_description+": "+self.value

class Manager(Human):
    def push_developer(self, developer):
        print('Give me code now!!!')
        code = developer.make_some_code()
        return code
```

Але програмісти завжди хочуть використовувати нові та зручні технології і Python-розробник вивчив один із магічних методів (метод __str__ ) та технологію f-рядків, і тепер повертає інформацію про те що він програміст і знає Python з використанням цих технологій.

```python
class PythonDeveloper(Human):  # Створюємо дочірній клас, який успадковує клас `Human`
    field_description = "My Programming language"
    value = "Python"
    def make_some_code(self):
        return self.field_description+": "+self.value
    def __str__(self):
        return f"{self.field_description}: {self.value}"
```
###  Приклади спадкування
Створено клас (`DataField`), що описує загальний елемент бази даних. І одне з полів (`field_description`) зберігає опис типу елементу. При розробці, таку саму структуру класу можна використати для опису специфічного елементу, що описує країну (`CountryField`).  

Зазвичай в класі (`DataField`) є реалізовані методи, котрі зручно використовувати в дочірньому класі(`CountryField`), тому `CountryField` успадковується від `DataField`, але значення поля `field_description` змінюється на `"country"`.
```python
class DataField:
    field_description = "General"

    def __init__(self, value):
        self.value = None
        self.validate(value)
class CountryField:
    field_description = "country"
```

## Контейнери, створені шляхом успадкування (UserList, UserDict, UserString).
## Поліморфізм
## Контейнери, створені шляхом агрегації.
## "Качина" типізація
## Область видимості по відношенню до класів Python (правило LEGB). 
## Method Resolution Order (MRO).
## Вправи

# Файли
## Вступ
## Відкриття файлів
## Текстовий файл і рядки
## Читання файлів
## Пошук через файл
## Оператор with
## Запис файлів
## Форматування рядків. 
## Регулярні вирази, пакет re 
## Context-функції.managers. 
## Робота з файловою системою (os, pathlib, shutil, видалення, копіювання, архівація файлів і каталогів). 
## Серіалізація за допомогою pickle. 
## Серіалізація даних в json
** Серіалізація/десеріалізація об'єктів Python в/з JSON**
Всю свою історію людство використовує різні формати передачі даних. Спочатку, це були наскельні малюнки, потім письмові документи. Але швидкість доставки паперового листа обмежена швидкістю коня, який везе листоношу, як це було в середньовіччі, або швидкістю літака,потяга,автівки в наш час.
Першою спробою використовувати формат передачі даних, що не прив'язаний до матеріального носія можна вважати азбуку Морзе, коли букви шифрувалися за допомогою крапочок і тире, та передавалися спочатку світлофорною сигналізацією, а потім - через телеграф.
<img src="python-bc-ab-json/img/morsecode.png" alt="Азбука Морзе" style="width:200px"/>
Сьогодні передавати просто текст - це також не відповідає вимогам часу. Програмісти навчилися передавати змінні зі значеннями та цілі об'єкти. 
Найпоширенішим форматом передачі даних на сьогодні є формат JSON. Наприклад: ось формат передачі курсів валют із сайту Приватбанку в форматі JSON
```python
[
    {"ccy":"USD","base_ccy":"UAH","buy":"27.20000","sale":"27.60000"},
    {"ccy":"EUR","base_ccy":"UAH","buy":"31.95000","sale":"32.60000"},
]
```
Формат збереження даних JSON є дуже зручним для роботи з ним і для передачі по мережі, однак 
JSON дозволяє зберігати лише найпростіші об'єкти і типи даних:
* `int`
* `float`
* `str`
* `dict`
* `list`
* `tuple` (конвертючи його в `list`) 

в якості ключів в словнику можна використовувати лише рядки (`str`). 

Але JSON не дає змоги зберігати власні об'єкти Python, наприклад `Record`, `EmailField`.
Однак, ми можемо створити методи і/або функції, які перетворюють наші об'єкти в словник і назад.

## DataField <-> JSON

Для відновлення об'єкту із словника виду `{"value": self.value, "field_name": self.field_description}`, ми
створимо функцію `field_decoder` (*рядок №12*) . Ця функція отримує на вхід словник (параметр `field_dict`) та повертає об'єкт `DataField`, чи його нащадок.

Створимо об'єкт `registered_fields` (*рядок №13*), що є нащадком `DataField`, який в подальшому використаємо для підготовки результату, що повертає наш метод:
```python
registered_fields = {
    DataField.field_description: DataField,
    FirstNameField.field_description: FirstNameField,
}
```
Отримаємо ключ та значення з параметру `field_dict` в окремі змінні `field_name` та `field_value` відповідно (*рядки №17,18*).
Далі - визначимо змінну, що має назву `field_class`, яка отримає, в якості значення, результат ініціації об'єкту `registered_fields` із значенням ключа зі змінної `field_name`.
```python
    field_class = registered_fields[field_name]
```
і вже після цього передамо створеному об'єкту `field_class` значення `field_value`
```python
    field = field_class(field_value)
```
В Python все є об'єктом (ну майже все). Тому існує можливість в словниках і списках зберігати класи і функції, передавати їх, 
в якості аргументу функції, чи результату її виконання, можливо зберігати класи у змінні, тощо. Така особливість стає нам 
в нагоді в функції `field_decoder`.

## File-like objects.
## Вправи

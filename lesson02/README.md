# Модуль 2a. Управление потоком выполнения
По-умолчанию в Python команды выполняются одна за одной сверху вниз. Последовательность запуска команд в программе называется «поток выполнения» (Flow of execution). 
Программы, в которых все команды выполняются одна за одной называются *линейными программами*.
В программировании существует всего 2 структуры, которые изменяют поток выполнения: 
- ветвления (оператор выбора)
- циклы.  
Обе данные структуры (и цикл и оператор выбора) используют *логические выражения.* 
## Логические выражения
Логические выражения - это набор значений и *операторов*, результатом выполнения которых будет значения типа boolean (True - правда или False - ложь).
Например: 3>3 (Fales), 7>=2 (False), 2*2==4 (True)
## Логические операторы
Чаще всего используются такие логические операторы:


- Равно	==	
- Не равно	!=	
- Больше	>	
- Меньше	<	
- Больше или равно	>=	
Меньше или равно	<=
## Булева алгебра
## Булева алгебра
В Python існує булевський (логічний) тип даних. Змінні цього типу мають лише два значення: 
`True` (істина) та `False` (хибність). 
Для булевського типу даних визначені логічні операції логічного та (`and`), логічного або (`or`), логічного ні (`not`).
Результати даних операцій наведені в таблиці.


### and

<table class="tg">
<thead>
  <tr>
    <th class="tg-c3ow">A</th>
    <th class="tg-c3ow">B</th>
    <th class="tg-c3ow">A and B</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
  </tr>
</tbody>
</table>

### or
<table class="tg">
<thead>
  <tr>
    <th class="tg-c3ow">A</th>
    <th class="tg-c3ow">B</th>
    <th class="tg-c3ow">A or B</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">True</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">False</td>
  </tr>
</tbody>
</table>

#### not

<table class="tg">
<thead>
  <tr>
    <th class="tg-c3ow">A</th>
    <th class="tg-c3ow">not A</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c3ow">True</td>
    <td class="tg-c3ow">False</td>
  </tr>
  <tr>
    <td class="tg-c3ow">False</td>
    <td class="tg-c3ow">True</td>
  </tr>
</tbody>
</table>


### Створення змінних булівського типу
```python
a = True
b = False
c = a and b
d = a or b 
e = not a
print(c)    # False
print(d)    # True
print(e)    # False
```

### Об'єкт типу `None`
В Python існує спеціальний об'єкт `None` для тих випадків, коли ми хочемо створити об'єкт
який не має ні значення, ні типу, пустий об'єкт.

```python
a = None
print(a)
``` 

Функція, яка нічого не повертає насправді повертає `None`. В деяких випадках, коли ми хочемо вказати
на факт, що результат роботи коду невизначений можна використовувати `None`.


## Условное выполнение
В Python реализован оператор контроля выполнения (условный оператор) `if ... elif ... else`.

С помощью этого инструмента существует возможность контролировать поток выполнения
(По умолчанию выполняются все команды сверху вниз).
Оператор контроля исполнения позволяет выполнять определенные участки кода не всегда,
а только тогда, когда будет выполнено определенные условия.

Синтаксис оператора выбора состоит из обязательного ключевого слова `if` и необязательных `elif`, `else`.

Условный оператор начинается с ключевого слова `if` за которым следует условие (переменная типа` bool`, или выражение,
который возвращает `bool`).
После условия ставится двоеточие и с новой строки с отступом идет один или более операторов,
которые будут выполнены в случае, когда условие будет равняться `True`.
После блока `if` может быть ноль или более блоков `elif`, интерпретатор последовательно будет проверять
все условия `elif` сверху вниз, пока не найдет ту, которая возвращает `True`, или они закончатся.
После блока (ов) `elif` может содержаться один блок `else`, который выполнится, если все предыдущие условия равны `False`.

## Условия
В качестве операторов условий часто используют сравнения.
Сравнение происходит с помощью операторов `<` (меньше), `<=` (меньше или равно),
  `>` (Больше), `>=` (больше или равно), `==` (равно), `!=` (Не равно).

```python
a = 3
b = 5
c = a < b # True
d = a > b # False
```

Определим с помощью оператора выбора есть число, его ввел пользователь положительным (больше нуля).
```python
a = input('Введите число')
if int(a) > 0:
    print("Число положительное")
```
Но бывают случаи, когда нам одного сравнения недостаточно для того, чтобы решить задачу. В случае анализа числа нам необходимо дать ответ когда число положительное (больше нуля), отрицательное (меньше нуля) и когда непосредственно является нулем.
```python
a = int(input('Введите число'))
if a > 0:
    print('Число положительное')
elif a < 0:
    print("Число отрицательное")
else:
    print('Это число - ноль')
```
Во время выполнения условного оператора интерпретатор Python проверяет условия сверху вниз пока не найдет ту,
которая выполняется, затем выполнит выражение для этого условия и выйдет по проверке условий.

```python
a = int(input('Введите число'))
if a > 0:
    print('Число положительное')
elif a == 1:
    print('Число равно 1')
else:
    print("a < 0")
```
В таком случае код для условия `a == 1` никогда не исполнится.

Разберем реализацию условного оператора на примере определения агрегатного состояния воды
(Лед, вода, пар), то есть если вода имеет температуру ниже 0 градусов по
Цельсию - она превращается в лед, если вода имеет температуру от 0 до 100 градусов
она находится в жидком состоянии, то есть непосредственно водой
и, если температура воды выше 100 градусов, она превратится в пар.

```python
t = input("Введите температуру воды")
# Перетворимо рядок t на число
t = int(t)
if t <= 0:
    print("Это - лед")
elif 0 < t < 100:
    print("Это - вода")
else:
    print("Это - пар")
```
## Последовательность условий
Условие в операторе выбора может быть составным.
```python
t = input("Введите температуру воды")
# Перетворимо рядок t на число
t = int(t)
if t <= 0:
    print("Это - лед")
elif t > 0 and t < 100:
    print("Это - вода")
else:
    print("Это - пар")
```

<table>
<tr>
<td>or</td><td>Логическое “ИЛИ”</td>
</>
<tr>
<td>and</td><td>Логическое “И”</td>
</tr>
<tr>
<td>not x</td><td>Логическое “НЕ”</td>
</tr>
<tr>
<td><, <=, >, >=, !=, ==</td><td>Сравнения</td>
</tr>
<tr>
<td>*, /, //, %</td><td>	Умножение, деление, целочисленное деление и остаток от деления</td>
</tr>
<tr>
<td>+x, -x</td><td>	Положительное, отрицательное</td>
</tr>
<td>**</td><td>	Возведение в степень</td>
</tr>
<tr>

</table>

	
	
	
	
	
	

## Вложенные условия
В Python внутрь одного оператора может быть вложен другой.
Пример такой вложенности для определения четвертей для координатной плоскости.
```python
    if x > 0:
    if y > 0:               # x>0, y>0
        print("Первая четверть")
    else:                   # x>0, y<0
        print("Четвертая четверть")
else:
    if y > 0:               # x<0, y>0
        print("Вторая четверть")
    else:                   # x<0, y<0
        print("Третья четверть")
```

## Перехват исключений с использованием try и except

Виключення в Python &mdash; це помилки на рівні механізму запуску програми (інтерпретатору), які викликані неможливістю виконати той чи інший оператор, з будь-яких причин (змінна не існує,
синтаксична помилка, відсутній атрибут, операція ділення на нуль, тощо).

Наприклад, наш скрипт очікує даних від користувача в форматі цілого числа. Однак, користувач може ввести будь-який символ (наприклад рядок 'a'), в такому разі, при спробі конвертувати введений символ в число, станеться помилка:

```python
val = 'a' #навмисно робимо  значення змінної val таким, що викличе помилку
print("Ви ввели: ", int(val)) # цей код викликає помилку
```
В даному випадку програма припинить свою роботу і користувач так і не дізнається, що привело до цього збою. Проте ми можемо обробити цю помилку (така помилка називається `ValueError`).

`ValueError`, це помилка (виключення), що стається у випадку неможливості конвертувати передане значення у необхідний тип даних.  

В нашому прикладі (введено 'а') інтерпретатору намагається перетворити рядок на `int` (ціле число), але як конвертувати рядок `'a'` в число він не знає і викликає виключення з цього приводу.

## Механізм обробки виключень

Для обробки виключень існує оператор `try ... except ...`. Синтаксично, цей оператор починається з ключового слова `try:` (спробувати) і продовжується 
блоком коду на наступному рядку, який виділений відступом.

Далі йде блок обробки виключень `except` (окрім), де можна вказати одне, 
або більше виключень, після яких виконати наступний блок коду.

В нашому прикладі обробка користувацького вводу виглядатиме наступним чином:

```python
val = 'a'
try:
    print("Ви ввели: ", int(val))
except ValueError:
    print("Введено некоректний символ")
```

## Власні виключення
Більшість виключень в Python детально описані та формують читабельний і детальний звіт стосовно
причини, що викликала неможливість виконання операції.
Однак, для зручності, програміст може створити свої класи помилок, щоб згодом обробляти їх певним чином.

Для __створення__ **власного виключення** достатньо створити клас, який успадковує `Exception` &mdash; це батьківський клас всіх виключень в Python.

```python
class IncorrectInput(Exception): #Назва власного виключення може бути будь-якою
    pass
```
Якщо синтаксис вимагає наявність оператора, але нам не потрібно нічого виконувати, то оператор `pass` стане у нагоді. Бо оператор `pass`, як раз створений нічого не виконувати.

Щоб __викликати__ *власне виключення* існує оператор `raise`: 

```python
   def validate(self, value):
        try:
            self.value = float(value)
        except ValueError: 
            raise IncorrectInput()
```

Але для того, щоб зрозуміти яке виключення спрацювало, краще додавати повідомлення про це:

```python
   def validate(self, value):
        try:
            self.value = float(value)
        except ValueError: 
            raise IncorrectInput(f"value {value} can't be converted to float")
```

## Упражнения

# Модуль 2b. итерации
## Цикли
Цикли - це алгоритмічні керуючі конструкції, 
які дозволяють виконувати певні операції (тіло циклу) декілька разів.


### Цикл while

Цикл `while` дозволяє виконувати оператори, які знаходяться в тілі циклу доти, доки виконується умова,
що вказана в циклі. Наприклад, цикл `while`, що виводить числа від 1 до 5

```python
a = 1
while a <= 5:
    print(a)
    a += 1
```

Умовою може бути будь-який вираз, або змінна Python, що може бути приведена до типу `bool`.

## «Бесконечные циклы» и break
Бывают ситуации, в которых выход из цикла происходит не из-за изменения условия в управляющей команде цикла, а благодаря срабатыванию команды `break`.
Команда `break` - полностью останавливает цикл.
```python
a = 0
while True:
    print(a)
    if a == 20:
        break
    a +=1
```
## Завершение итерации с помощью continue
В Python
```python
a = 0
while a < 20:
    a +=1
    if a % 2 == 0:
        continue
    print(a)
```

## Comprehensions (list, dict, set).
## Определение циклов с помощью for
### Цикл for
В Python, цикл `for` використовується для перебору будь-яких контейнерів, 
або ітерованих об’єктів, наприклад, списків. 
Оператори, які знаходяться в тілі циклу будуть виконані стільки разів, скільки елементів є в списку. 

При цьому, на кожному кроці спеціальна змінна отримує значення одного з елементів списку.

Роботу циклу `for` можна порівняти з тим що, ви по черзі візьмете кожен фрукт з корзини 
і проговорите його назву (корзиною в даному випадку буде виступати список рядків з назвами фруктів, 
а проговоренням буде виступати виведення відповідних рядків на екран)

```python
fruits = ['apple', 'pear', 'apricot', 'orange', 'plum']
for fruit in fruits:
    print(fruit)
```

Цикл `for` на практиці використовується для формування нових переліків на основі вже існуючих. 
Наприклад, з існуючого переліку (з числами від 1 до 10) перенесемо в новий перелік лише ті числа, 
що кратні 3.

Визначення кратності забезпечується за рахунок оператору `%` ("залишок від ділення"). 
Тобто, якщо залишок від ділення числа на 3 дорівнює нулю, то таке число кратне 3.

Також важливою особливістю є те, що 0 відповідає логічному значенню `False` тобто вирази 
`a % 3 == 0` та `not a % 3` будуть еквівалентними.

Приклад роботи такого оператору:

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = []
for elem in a:
    if not elem % 3:
       result.append(elem)

print(result)   # Виведе [3, 6, 9]
```

## Обход списков с помощью цикла for
## Упражнения